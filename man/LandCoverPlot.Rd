% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LandCoverPlot.R
\name{LandCoverPlot}
\alias{LandCoverPlot}
\title{Predict values from \code{gls_spatial()} output}
\usage{
LandCoverPlot(
  raster,
  value_type = "continuous",
  blank_background = TRUE,
  legend_title = element_blank(),
  font_size = 11,
  break_at_zero = FALSE,
  priority_categories = 5,
  priority_outlier_value = NA,
  decimal_points = 0,
  priority_colors = if (!is.na(priority_outlier_value)) {     c("lightgray",
    viridis::viridis(priority_categories + 1)) } else {     c("lightgray",
    viridis::viridis(priority_categories)) },
  flip_colors = FALSE,
  RColorBrewer_type = "qual",
  RColorBrewer_palette = "Dark2",
  continuous_type = "viridis",
  continuous_break0_low = "#440154FF",
  continuous_break0_high = "#FDE725FF",
  continuous_break0_mid = "lightgray",
  categorical_direction = 1
)
}
\arguments{
\item{raster}{a \code{raster} object. The raster you wish to plot}

\item{value_type}{character string. Specifies whether the values you are plotting are \code{'continuous'}, \code{'categorical'}, or \code{'priority'}. Default is \code{'continuous'}. See details.}

\item{blank_background}{logical. Do you want to remove the plot background (i.e. grid lines, tick marks, legend titles, etc.)? Default is \code{TRUE}}

\item{legend_title}{character string. The legend title. Default is blank.}

\item{font_size}{numerical. Font size of text in the plot. Default is 11.}

\item{break_at_zero}{logical. Should categories be split at 0? Works for continuous and priority plots. Default is \code{FALSE}.}

\item{priority_categories}{numerical. If \code{value_type = 'priority'}, specifies the number of non-zero priority categories to plot. Default is 5. If \code{priority_colors} are not specified, max value is 9.}

\item{priority_outlier_value}{numerical. A value specifying an additional priority category for outliers. Can be either positive or negative.}

\item{decimal_points}{numerical. Specifies the number of decimal points to report in the legend. Default is 0.}

\item{priority_colors}{vector. If \code{value_type = 'priority'}, a vector of colors of \code{length(priority_categories)+1} to customize priority category colors. The first value is for 'No change', and the rest are for the priority categories. Default is rainbow colors, with values of 0 being grayed out. If \code{priority_outlier_value} is provided, an additional color must be specified for the outlier category. That is, you must provide a vector of \code{length(priority_categories)+2} colors.}

\item{flip_colors}{logical. Should the priority colors be flipped? Default is \code{FALSE}. Useful for negative values.}

\item{RColorBrewer_type}{character string. For \code{value_type = 'categorical'}, specify the \code{RColorBrewer} \code{type}. See \code{?RColorBrewer}. Default is \code{'qual'}}

\item{RColorBrewer_palette}{character string. For \code{value_type = 'categorical'}, specify the \code{RColorBrewer} \code{palette}. See \code{?RColorBrewer}. Default is \code{'Dark2'}}

\item{continuous_type}{character string. For \code{value_type = 'continuous'}, specify color scale. See \code{?scale_fill_continuous}. Default is colorblind-friendly \code{viridis}.}

\item{continuous_break0_low}{character string. For \code{value_type = 'continuous'} and \code{break_at_zero = TRUE}, set the low color. See \code{?scale_color_gradient2}.}

\item{continuous_break0_high}{character string. For \code{value_type = 'continuous'} and \code{break_at_zero = TRUE}, set the high color. See \code{?scale_color_gradient2}.}

\item{continuous_break0_mid}{character string. For \code{value_type = 'continuous'} and \code{break_at_zero = TRUE}, set the color for values of 0. See \code{?scale_color_gradient2}.}

\item{categorical_direction}{numerical. For \code{value_type = 'categorical'}, flip the direction of the color scale by setting the value to \code{-1}.}

\item{...}{Pass additional arguments to adjust the legend and coloring (breaks, labels, limits, color/fill, etc.)}
}
\value{
A a \code{ggplot} object
}
\description{
After creating \code{gls} object(s) with the \code{gls_spatial()} function, this will create predicted values of the dependent variable from your regression, for the specified landcovers. Particularly useful once your landcover files have changed and you want to predict what effect this may have on the dependent variable.
}
\details{
See ?ggplot and ?scale_fill_continuous and ?scale_fill_manual for details about plotting with ggplot and adjusting the legend and colors
}
\examples{
set.seed(1)
library(LandCover); library(gridExtra); library(ggplot2); library(raster); library(foreach); library(rasterVis)


# initialize data.frame with coordinates
dat <- expand.grid(x = 1:20, y = 1:20, KEEP.OUT.ATTRS = FALSE)


# create some data: elevation, landcover, and temp/ET dependent on elevation and landcover
dat$elevation <- with(dat, 50 + 2*x + 5*y + rnorm(nrow(dat), sd = 7))
dat$landcover <- ifelse(dat$elevation < median(dat$elevation), 1, 2)
dat[dat$x < median(dat$x) & dat$landcover == 2, 'landcover'] <- 3
dat$temp      <- with(dat, (120-0.7*(0.5*elevation + 0.3*y - 0.5*x + ifelse(landcover == 'lc1', -30, 0) + rnorm(nrow(dat)))))
dat$ET        <- with(dat, (   -0.4*(-2*temp       + 0.5*y - 1.0*x + ifelse(landcover == 'lc1', +20, 0) + rnorm(nrow(dat)))))


# run regression
regression_results <- gls_spatial(data = dat, landcover_varname = 'landcover', landcover_vec = c(1,2), reg_formula = ET ~ elevation + temp, error_formula = ~x+y)

# get predicted values data
predicted_values <- gls_spatial_predict(data = dat, regression_results = regression_results, landcover_varname = 'landcover', landcover_invasive = 1, landcover_susceptible = 2, dep_varname = 'ET',
                                        x_coords_varname = 'x', y_coords_varname = 'y')

LandCoverPlot(ET_predicted_lc1_raster)
}

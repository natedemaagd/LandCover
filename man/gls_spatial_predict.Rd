% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gls_spatial_backup.R, R/gls_spatial_predict.R
\name{gls_spatial_predict}
\alias{gls_spatial_predict}
\title{Predict values from \code{gls_spatial()} output}
\usage{
gls_spatial_predict(
  data,
  regression_results,
  landcover_varname,
  landcover_invasive,
  landcover_susceptible,
  dep_varname,
  x_coords_varname,
  y_coords_varname
)

gls_spatial_predict(
  data,
  regression_results,
  landcover_varname,
  landcover_invasive,
  landcover_susceptible,
  dep_varname,
  x_coords_varname,
  y_coords_varname
)
}
\arguments{
\item{data}{\code{data.frame} with spatial data}

\item{regression_results}{object of class \code{gls} from the \code{gls_spatial} function}

\item{landcover_varname}{character string. The name of the landcover variable in \code{data}}

\item{landcover_invasive}{value. Numerical or character value of the invasive landcover.}

\item{landcover_susceptible}{value. Numerical or character value(s) of the susceptible landcover(s). If more than one susceptible landcover, provide a vector \code{c()}.}

\item{dep_varname}{character string. Name of the dependent variable in \code{data}.}

\item{x_coords_varname}{character string. Name of the x-coordinate variable in \code{data}.}

\item{y_coords_varname}{character string. Name of the y-coordinate variable in \code{data}.}

\item{reg_results}{object of class \code{gls} from the \code{gls_spatial} function}

\item{landcover_val}{numerical or character. Value of landcover for which the new dependent variable values are to be predicted. Either a specific landcover from your data, or \code{'ALL'}.}

\item{return_raster}{logial. Do you want the result returned as a raster? Default is \code{FALSE}, and a vector is returned. If \code{TRUE}, you must specify the \code{x_coords} and \code{y_coords} from the data.}

\item{x_coords}{vector. A vector of length \code{nrow(data)} specifying the x-coordinates of the raster. Required if \code{return_raster = TRUE}.}

\item{y_coords}{vector. A vector of length \code{nrow(data)} specifying the y-coordinates of the raster. Required if \code{return_raster = TRUE}.}
}
\value{
A vector with predicted values of the dependent variable from gls_spatial()

A list of predicted values for current landcover, invaded landcover, and the associated rasters.
}
\description{
After creating \code{gls} object(s) with the \code{gls_spatial()} function, this will create predicted values of the dependent variable from your regression, for the specified landcovers. Particularly useful once your landcover files have changed and you want to predict what effect this may have on the dependent variable.

After creating \code{gls} object(s) with the \code{gls_spatial()} function, this will create predicted values of the dependent variable from your regression, for the specified landcovers. Particularly useful once your landcover files have changed and you want to predict what effect this may have on the dependent variable.
}
\details{
This GLS predict function relies on a model created with the gls_spatial() function. It will not work if it is run independently (or before) the gls_spatial() function has been used to create the \code{reg_results} parameter.

This GLS predict function relies on a model created with the gls_spatial() function. It will not work if it is run independently (or before) the gls_spatial() function has been used to create the \code{regression_results} parameter. It returns a list of four objects: (1)a vector of predicted values under the current landcover; (2) a vector of predicted values assuming the invasive landcover takes the place of all susceptible landcovers; (3) a raster of predicted values under the current landcover; and (4) a raster of predicted values assuming the invasive landcover takes the place of all susceptible landcovers.
}
\examples{
set.seed(1)
# load packages
library(LandCover); library(foreach); library(raster)

# initialize data.frame with coordinates
dat <- expand.grid(x = 1:20, y = 1:20, KEEP.OUT.ATTRS = FALSE)

# create some data: elevation, landcover, and temp/ET dependent on elevation and landcover
dat$elevation <- with(dat, 50 + 2*x + 5*y + rnorm(nrow(dat), sd = 7))
dat$landcover <- ifelse(dat$elevation < median(dat$elevation), 1, 2)
dat$temp      <- with(dat, (120-0.7*(0.5*elevation + 0.3*y - 0.5*x + ifelse(landcover == 'lc1', -30, 0) + rnorm(nrow(dat)))))
dat$ET        <- with(dat, (   -0.4*(-2*temp       + 0.5*y - 1.0*x + ifelse(landcover == 'lc1', +20, 0) + rnorm(nrow(dat)))))

# run the gls model
regression_results <- gls_spatial(data = dat, landcover_varname = 'landcover', landcover_vec = c(1,2),
                                  reg_formula = ET ~ elevation + temp, error_formula = ~ x + y)

# get the expected values of present-day ET, using both types of landcover
dat$ET_predicted_ALL <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 'ALL')

# create raster of predicted values using one landcover type
ET_predicted_lc1_raster  <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 1,
                                                return_raster = TRUE, x_coords = dat$x, y_coords = dat$y)

set.seed(1)
# load packages
library(LandCover); library(foreach); library(raster)

# initialize data.frame with coordinates
dat <- expand.grid(x = 1:20, y = 1:20, KEEP.OUT.ATTRS = FALSE)

# create some data: elevation, landcover, and temp/ET dependent on elevation and landcover
dat$elevation <- with(dat, 50 + 2*x + 5*y + rnorm(nrow(dat), sd = 7))
dat$landcover <- ifelse(dat$elevation < median(dat$elevation), 1, 2)
dat$temp      <- with(dat, (120-0.7*(0.5*elevation + 0.3*y - 0.5*x + ifelse(landcover == 'lc1', -30, 0) + rnorm(nrow(dat)))))
dat$ET        <- with(dat, (   -0.4*(-2*temp       + 0.5*y - 1.0*x + ifelse(landcover == 'lc1', +20, 0) + rnorm(nrow(dat)))))

# run the gls model
regression_results <- gls_spatial(data = dat, landcover_varname = 'landcover', landcover_vec = c(1,2),
                                  reg_formula = ET ~ elevation + temp, error_formula = ~ x + y)

predicted_values <- gls_spatial_predict(data = dat, regression_results = regression_results, landcover_varname = 'landcover', landcover_invasive = 1, landcover_susceptible = 2, dep_varname = 'ET',
                                        x_coords_varname = 'x', y_coords_varname = 'y')

}

---
title: "LandCover example"
author: "Nathan DeMaagd"
date: "9/22/2020"
output: html_document
---





This markdown file contains all the examples from the LandCover documentation on my GitHub page. It is fully executable and will reproduce all results and figures shown in the examples.







# Initial setup


File setup. Here we load the packages we'll use in this tutorial, including the `LandCover` package. The others are used for plotting figures, working with rasters, and running code in parallel.

```{r file setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set.seed(1)
library(LandCover); library(gridExtra); library(ggplot2); library(raster); library(foreach)

```




Suppose we have a data.frame with the variables x, y, elevation, landcover, temp, and ET (evapotranspiration). We may be interested in how these variables interact with one another within a given landcover.

```{r example data setup}


# initialize data.frame with coordinates
dat <- expand.grid(x = 1:20, y = 1:20, KEEP.OUT.ATTRS = FALSE)


# create some data: elevation, landcover, and temp/ET dependent on elevation and landcover
dat$elevation <- with(dat, 50 + 2*x + 5*y + rnorm(nrow(dat), sd = 7))
dat$landcover <- ifelse(dat$elevation < median(dat$elevation), 1, 2)
dat$temp      <- with(dat, (120-0.7*(0.5*elevation + 0.3*y - 0.5*x + ifelse(landcover == 'lc1', -30, 0) + rnorm(nrow(dat)))))
dat$ET        <- with(dat, (   -0.4*(-2*temp       + 0.5*y - 1.0*x + ifelse(landcover == 'lc1', +20, 0) + rnorm(nrow(dat)))))


# create plot of variables
plot_elevation <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = elevation)) + scale_fill_gradientn(colors = terrain.colors(5))             + coord_equal() + labs(title = 'Elevation data')
plot_temp      <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = temp))      + scale_fill_gradient(low = "green", high = "darkorange")      + coord_equal() + labs(title = 'Temperature data')
plot_ET        <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = ET))        + scale_fill_gradient(low = "tan", high = "red")               + coord_equal() + labs(title = 'ET data')
plot_landcover <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = as.character(landcover))) + coord_equal() + labs(title = 'Landcover data') + scale_fill_manual(values = c('chartreuse3', 'chartreuse4'),
                                                                                                                                                                         name = 'landcover')

plot_grid <- grid.arrange(plot_elevation, plot_temp, plot_ET, plot_landcover, ncol=2)

plot_grid

#ggsave(plot = plot_grid, filename = "C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/raster_plots.png", dpi = 300, width = 6, height = 6)




### if you have rasters, you'll need to first convert to data.frames and combine

     # create rasters as an example, using the existing data created above (!!!!skip this in your own data since you already have rasters!!!!)
     raster_terrain   <- rasterFromXYZ(dat[c('x', 'y', 'elevation')])
     raster_landcover <- rasterFromXYZ(dat[c('x', 'y', 'landcover')])
     raster_temp      <- rasterFromXYZ(dat[c('x', 'y', 'temp')])
     raster_ET        <- rasterFromXYZ(dat[c('x', 'y', 'ET')])

# convert rasters to data.frames
dat_terrain   <- as.data.frame(raster_terrain,   xy = TRUE)
dat_landcover <- as.data.frame(raster_landcover, xy = TRUE)
dat_temp      <- as.data.frame(raster_temp,      xy = TRUE)
dat_ET        <- as.data.frame(raster_ET,        xy = TRUE)

# merge new data.frames by coordinates
merge_func <- function(x, y)
  merge(x, y, by=c("x", "y"), all=TRUE)

dat <- Reduce(merge_func, list(dat_terrain, dat_landcover, dat_temp, dat_ET))

rm(merge_func, dat_terrain, dat_landcover, dat_temp, dat_ET)

```









# Using `gls_spatial`

Setting up the data for the example was more complicated than actually running the function once you have a data.frame. To run the function, you'll need to specify, at a minimum, the data, the name of the landcover variable in the data, a vector of specific landcover values for which you want regression results, a regression formula, and the error formula (the coordinates from the data). For our example, let's say we want to test both landcover types, 1 and 2. For each type of landcover, we might be interested in analyzing the relationship between ET, elevation, and temperature. We would set up the function like this:

```{r using gls_spatial}


# run regression
regression_results <- gls_spatial(data = dat, landcover_varname = 'landcover', landcover_vec = c(1,2), reg_formula = ET ~ elevation + temp, error_formula = ~x+y)

# what form of error correlation was chosen for the regressions? Linear for landcover type 1 and Ratio for landcover type 2
regression_results[[1]]$modelStruct$corStruct
regression_results[[2]]$modelStruct$corStruct

# print a summary of regression from both landcover types
summary(regression_results[[1]])
summary(regression_results[[2]])

# we don't need anything other than the data and regression results now, so delete everything other than those two things
rm(list=setdiff(ls(), c('dat', 'regression_results')))

```









# Using `gls_spatial_predict`

Before you get into changing the landcovers and predicting new values, you'll most likely want to get predicted values for your present-day dependent variable. This is because you'll want to compare the *expected* values of today to the *expected* values of the future. If you compare the *true* values of today with the *expected* values of the future, you may get some weird predicted changes that don't make ecological, biological, etc. sense. This could be because of measurement error in the given raster pixel, mis-classification, omitted variables, or any number of reasons.

The second half of this example shows how you can return a raster of predicted values, rather than a vector. This will be useful for the landcover spread portion of your project, because you'll want to know the expected values of the dependent variable for the new landcover type.

```{r using gls_spatial_predict}




##### use function to return vector of values #####


### get expected values of current ET for both landcover types

# get the expected values of present-day ET, using both types of landcover
dat$ET_predicted_ALL <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 'ALL')

# plot difference between actual and predicted values for each landcover type
plot_PredictedVsActual <- ggplot(data = dat) +
  geom_histogram(aes(x = ET - ET_predicted_ALL, fill = as.character(landcover), color = as.character(landcover)), alpha = 0.5, bins = 40) +
  geom_vline(xintercept = 0, linetype = 'longdash') +
  labs(x = latex2exp::TeX('$ET - \\widehat{ET}$'), y = 'Number of pixels', fill = 'Landcover', color = 'Landcover')

plot_PredictedVsActual

#ggsave(plot = plot_PredictedVsActual, filename = "C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/plot_PredictedVsActual.png", dpi = 300, width = 6, height = 6)

# get predicted values for a given landcover
dat$ET_predicted_lc1 <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 1)




##### use function to return raster of predicted values #####

# predict ET assuming all pixels are landcover type 1, return raster
ET_predicted_lc1_raster  <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 1,
                                                return_raster = TRUE, x_coords = dat$x, y_coords = dat$y)

# do the same thing, but get predicted values assuming no change in landcover (i.e. specify landcover value as 'ALL')
ET_predicted_ALL_raster  <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 'ALL',
                                                return_raster = TRUE, x_coords = dat$x, y_coords = dat$y)

# create raster with difference between the two rasters above
ET_predicted_diff <- ET_predicted_lc1_raster - ET_predicted_ALL_raster


# plot the rasters, and the difference
plot(ET_predicted_diff)

```




# Using `LandCoverPlot`

This function serves to provide a `ggplot` of a raster with either continuous or categorical values.

```{r using LandCoverPlot}


### plot continuous values

#plot
LandCoverPlot(ET_predicted_diff, legend_title = 'ET difference')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot.png", dpi = 300, height = 7, width = 7)

# control color scheme
LandCoverPlot(ET_predicted_diff, legend_title = 'ET difference', low = 'blue', high = 'red')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_changeColor.png", dpi = 300, height = 7, width = 7)



### plot categorical values

# create landcover raster
lc_raster <- rasterFromXYZ(data.frame(x = dat$x, y = dat$y, z = dat$landcover))

# plot
LandCoverPlot(lc_raster, value_type = 'categorical', legend_title = 'Landcover type')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_categorical.png", dpi = 300, height = 7, width = 7)

# change color palette
LandCoverPlot(lc_raster, value_type = 'categorical', legend_title = 'Landcover type', RColorBrewer_palette = 'Set3')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_categorical_changeColor.png", dpi = 300, height = 7, width = 7)



### plot priority categories

# plot
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, legend_title = 'Change in ET')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority.png", dpi = 300, height = 7, width = 7)

# choose custom colors
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, priority_colors = c('black', 'tan', 'orange', 'blue', 'gray', 'limegreen'), legend_title = 'Change in ET')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority_changeColor.png", dpi = 300, height = 7, width = 7)

# specify an outlier
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, legend_title = 'Change in ET', priority_outlier_value = 1)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority_outlier.png", dpi = 300, height = 7, width = 7)


```

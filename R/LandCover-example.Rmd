---
title: "LandCover example"
author: "Nathan DeMaagd"
date: "9/22/2020"
output: html_document
---





This markdown file contains all the examples from the LandCover documentation on my GitHub page. It is fully executable and will reproduce all results and figures shown in the examples.







# Initial setup


File setup. Here we load the packages we'll use in this tutorial, including the `LandCover` package. The others are used for plotting figures, working with rasters, and running code in parallel.

```{r file setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set.seed(1)
library(LandCover); library(gridExtra); library(ggplot2); library(raster); library(foreach)
library(sp); library(tidyr); library(rgdal)

```




Suppose we have a data.frame with the variables x, y, elevation, landcover, temp, and ET (evapotranspiration). We may be interested in how these variables interact with one another within a given landcover.

```{r example data setup}


# initialize data.frame with coordinates
dat <- expand.grid(x = 1:20, y = 1:20, KEEP.OUT.ATTRS = FALSE)


# create some data: elevation, landcover, and temp/ET dependent on elevation and landcover
dat$elevation <- with(dat, 50 + 2*x + 5*y + rnorm(nrow(dat), sd = 7))
dat$landcover <- ifelse(dat$elevation < median(dat$elevation), 1, 2)
dat$temp      <- with(dat, (120-0.7*(0.5*elevation + 0.3*y - 0.5*x + ifelse(landcover == 'lc1', -30, 0) + rnorm(nrow(dat)))))
dat$ET        <- with(dat, (   -0.4*(-2*temp       + 0.5*y - 1.0*x + ifelse(landcover == 'lc1', +20, 0) + rnorm(nrow(dat)))))


# create plot of variables
plot_elevation <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = elevation)) + scale_fill_gradientn(colors = terrain.colors(5))             + coord_equal() + labs(title = 'Elevation data')
plot_temp      <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = temp))      + scale_fill_gradient(low = "green", high = "darkorange")      + coord_equal() + labs(title = 'Temperature data')
plot_ET        <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = ET))        + scale_fill_gradient(low = "tan", high = "red")               + coord_equal() + labs(title = 'ET data')
plot_landcover <- ggplot(data = dat) + geom_raster(aes(x = x, y=y, fill = as.character(landcover))) + coord_equal() + labs(title = 'Landcover data') + scale_fill_manual(values = c('chartreuse3', 'chartreuse4'),
                                                                                                                                                                         name = 'landcover')

plot_grid <- grid.arrange(plot_elevation, plot_temp, plot_ET, plot_landcover, ncol=2)

plot_grid

#ggsave(plot = plot_grid, filename = "C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/raster_plots.png", dpi = 300, width = 6, height = 6)




### if you have rasters, you'll need to first convert to data.frames and combine

     # create rasters as an example, using the existing data created above (!!!!skip this in your own data since you already have rasters!!!!)
     raster_terrain   <- rasterFromXYZ(dat[c('x', 'y', 'elevation')])
     raster_landcover <- rasterFromXYZ(dat[c('x', 'y', 'landcover')])
     raster_temp      <- rasterFromXYZ(dat[c('x', 'y', 'temp')])
     raster_ET        <- rasterFromXYZ(dat[c('x', 'y', 'ET')])

# convert rasters to data.frames
dat_terrain   <- as.data.frame(raster_terrain,   xy = TRUE)
dat_landcover <- as.data.frame(raster_landcover, xy = TRUE)
dat_temp      <- as.data.frame(raster_temp,      xy = TRUE)
dat_ET        <- as.data.frame(raster_ET,        xy = TRUE)

# merge new data.frames by coordinates
merge_func <- function(x, y)
  merge(x, y, by=c("x", "y"), all=TRUE)

dat <- Reduce(merge_func, list(dat_terrain, dat_landcover, dat_temp, dat_ET))

rm(merge_func, dat_terrain, dat_landcover, dat_temp, dat_ET)

```









# Using `gls_spatial`

Setting up the data for the example was more complicated than actually running the function once you have a data.frame. To run the function, you'll need to specify, at a minimum, the data, the name of the landcover variable in the data, a vector of specific landcover values for which you want regression results, a regression formula, and the error formula (the coordinates from the data). For our example, let's say we want to test both landcover types, 1 and 2. For each type of landcover, we might be interested in analyzing the relationship between ET, elevation, and temperature. We would set up the function like this:

```{r using gls_spatial}


# run regression
regression_results <- gls_spatial(data = dat, landcover_varname = 'landcover', landcover_vec = c(1,2), reg_formula = ET ~ elevation + temp, error_formula = ~x+y)

# what form of error correlation was chosen for the regressions? Linear for landcover type 1 and Ratio for landcover type 2
regression_results[[1]]$modelStruct$corStruct
regression_results[[2]]$modelStruct$corStruct

# print a summary of regression from both landcover types
summary(regression_results[[1]])
summary(regression_results[[2]])

# we don't need anything other than the data and regression results now, so delete everything other than those two things
rm(list=setdiff(ls(), c('dat', 'regression_results')))

```









# Using `gls_spatial_predict`

Before you get into changing the landcovers and predicting new values, you'll most likely want to get predicted values for your present-day dependent variable. This is because you'll want to compare the *expected* values of today to the *expected* values of the future. If you compare the *true* values of today with the *expected* values of the future, you may get some weird predicted changes that don't make ecological, biological, etc. sense. This could be because of measurement error in the given raster pixel, mis-classification, omitted variables, or any number of reasons.

The second half of this example shows how you can return a raster of predicted values, rather than a vector. This will be useful for the landcover spread portion of your project, because you'll want to know the expected values of the dependent variable for the new landcover type.

```{r using gls_spatial_predict}




##### use function to return vector of values #####


### get expected values of current ET for both landcover types

# get the expected values of present-day ET, using both types of landcover
dat$ET_predicted_ALL <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 'ALL')

# plot difference between actual and predicted values for each landcover type
plot_PredictedVsActual <- ggplot(data = dat) +
  geom_histogram(aes(x = ET - ET_predicted_ALL, fill = as.character(landcover), color = as.character(landcover)), alpha = 0.5, bins = 40) +
  geom_vline(xintercept = 0, linetype = 'longdash') +
  labs(x = latex2exp::TeX('$ET - \\widehat{ET}$'), y = 'Number of pixels', fill = 'Landcover', color = 'Landcover')

plot_PredictedVsActual

#ggsave(plot = plot_PredictedVsActual, filename = "C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/plot_PredictedVsActual.png", dpi = 300, width = 6, height = 6)

# get predicted values for a given landcover
dat$ET_predicted_lc1 <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 1)




##### use function to return raster of predicted values #####

# predict ET assuming all pixels are landcover type 1, return raster
ET_predicted_lc1_raster  <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 1,
                                                return_raster = TRUE, x_coords = dat$x, y_coords = dat$y)

# do the same thing, but get predicted values assuming no change in landcover (i.e. specify landcover value as 'ALL')
ET_predicted_ALL_raster  <- gls_spatial_predict(data = dat, reg_results = regression_results, landcover_varname = 'landcover', landcover_val = 'ALL',
                                                return_raster = TRUE, x_coords = dat$x, y_coords = dat$y)

# create raster with difference between the two rasters above
ET_predicted_diff <- ET_predicted_lc1_raster - ET_predicted_ALL_raster


# plot the difference raster
plot(ET_predicted_diff)

```




# Using `LandCoverPlot`

This function serves to provide a `ggplot` of a raster with either continuous or categorical values.

```{r using LandCoverPlot}


### plot continuous values

#plot
LandCoverPlot(ET_predicted_diff, legend_title = 'ET difference', font_size = 20)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot.png", dpi = 300, height = 5, width = 5)

# control color scheme
LandCoverPlot(ET_predicted_diff, legend_title = 'ET difference', font_size = 20, low = 'blue', high = 'red')
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_changeColor.png", dpi = 300, height = 5, width = 5)



### plot categorical values

# create landcover raster
lc_raster <- rasterFromXYZ(data.frame(x = dat$x, y = dat$y, z = dat$landcover))

# plot
LandCoverPlot(lc_raster, value_type = 'categorical', legend_title = 'Landcover type', font_size = 20)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_categorical.png", dpi = 300, height = 5, width = 5)

# change color palette
LandCoverPlot(lc_raster, value_type = 'categorical', legend_title = 'Landcover type', RColorBrewer_palette = 'Set3', font_size = 20)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_categorical_changeColor.png", dpi = 300, height = 5, width = 5)



### plot priority categories

# plot
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, legend_title = 'Change in ET', font_size = 20)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority.png", dpi = 300, height = 5, width = 5)

# choose custom colors
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, priority_colors = c('black', 'tan', 'orange', 'blue', 'gray', 'limegreen'), legend_title = 'Change in ET', font_size = 20)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority_changeColor.png", dpi = 300, height = 5, width = 5)

# specify an outlier cutoff value
LandCoverPlot(ET_predicted_diff, value_type = 'priority', decimal_points = 2, legend_title = 'Change in ET', font_size = 20, priority_outlier_value = 1)
#ggsave("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/Packages/LandCover/Figures/LandCoverPlot_priority_outlier.png", dpi = 300, height = 5, width = 5)


```




# Using `LandCoverSpread`

This function simulates the spread of a landcover type, given a spread rate and a list of landcovers that are susceptible to invasion.

```{r using LandCoverSpread}


# define landcover to spread
infest_val <- 1

# define landcovers that are susceptible to spread
suscep <- as.integer(c(2))
  
#spread_rate 
spreadrate <- growrate <- 0.05

# percent of random pixels that will be invaded even if not adjacent to an already-invaded pixel
birdcell <- 0.00

#simulation length (how far into the future will the sim run - years)
simlength <- 50

#simulation count (how many times to rep sim before calc a realization)
simulation_count <- 1000




##### function for one year #####

one_year <- function(
  x, 
  infested_value, 
  susceptible_values, 
  growth_rate = growrate, 
  bird_rate = birdcell, 
  old_aet = NULL, 
  pred_aet = NULL, 
  counter_layer = NULL
  ) {
  current_cells <- which(values(x) == infested_value)
  new_cells <- ceiling(length(current_cells) * growth_rate)
  
  adjacent_cells <- adjacent(x, which(values(x) == infested_value), directions = 8, pairs = FALSE)
  flippable_cells <- adjacent_cells[values(x)[adjacent_cells] %in% susceptible_values]
  if (length(flippable_cells) == 0) {
    return(list(
      #starting_cell_size = length(current_cells), 
      #new_cells = new_cells, 
      #flipped_cells = flipped_cells,
      #bird_cells = bird_cells,
      #bird_flipped_cells = bird_flips,
      infested_cell_count = sum(values(x) == infested_value, na.rm = TRUE),
      result = x,
      counter_layer = counter_layer,
      new_aet = old_aet
    ))
  }
  flipped_cells <- sample(flippable_cells, min(length(flippable_cells), new_cells))
  
  bird_cells <- sample(
    which(values(x) %in% c(infested_value, susceptible_values)), 
    ceiling(length(current_cells) * bird_rate)
  )
  # bird_cells <- sample(which(values(x) %in% susceptible_values), birds) # definitely flip birds
  bird_flips <- bird_cells[which(values(x)[bird_cells] %in% susceptible_values)]
  
  y <- x
  y[flipped_cells] <- infested_value
  y[bird_flips] <- infested_value
  
  all_flipped_cells <- unique(c(flipped_cells, bird_flips))
  if (!is.null(counter_layer)) {
    counter_layer[all_flipped_cells] <- counter_layer[all_flipped_cells] + 1
  }
  
  old_aet[flipped_cells] <- values(pred_aet)[flipped_cells]
  old_aet[bird_flips] <- values(pred_aet)[bird_flips]
  
  return(list(
    #starting_cell_size = length(current_cells), 
    #new_cells = new_cells, 
    #flipped_cells = flipped_cells,
    #bird_cells = bird_cells,
    #bird_flipped_cells = bird_flips,
    infested_cell_count = sum(values(y) == infested_value, na.rm = TRUE),
    result = y,
    counter_layer = counter_layer,
    new_aet = old_aet
  ))
}




##### run one iteration of the simulation #####

one_simulation <- function(x, periods, list_of_counters, old_aet, pred_aet) {
  # extend all raster extents
  x <- extend(x, extend(old_aet, pred_aet))
  old_aet <- extend(old_aet, x)
  pred_aet <- extend(pred_aet, x)

  sum_aet = rep(NA, times = periods)
  infested_cells = rep(NA, times = periods)
  mean_aet = rep(NA, times = periods)
  median_aet = rep(NA, times = periods)

  # run one simulation
  for (i in 1:periods) {
    one_year_result <- one_year(x, infested_value = infest_val, susceptible_values = suscep, 
                                growth_rate = growrate, bird_rate = birdcell, 
                                counter_layer = list_of_counters[[i]], 
                                old_aet = old_aet, pred_aet = pred_aet)
    sum_aet[i] <- sum(values(one_year_result$new_aet), na.rm = TRUE)
    infested_cells[i] <- one_year_result$infested_cell_count
    mean_aet[i] <- mean(values(one_year_result$new_aet), na.rm = TRUE)
    median_aet[i] <- median(values(one_year_result$new_aet), na.rm = TRUE)
    list_of_counters[[i]] <- one_year_result$counter_layer
    list_of_ETrasters[[i]] <- one_year_result$new_aet
    
    # use values from one_year() result for use in the next iteration
    x <- one_year_result$result
    old_aet = one_year_result$new_aet
  }
  
  return(list(
    sum_aet = sum_aet,
    infested_cells = infested_cells,
    mean_aet = mean_aet,
    median_aet = median_aet,
    list_of_counters = list_of_counters,
    list_of_ETrasters = list_of_ETrasters,
    et = old_aet
  ))
}




##### counter and ET raster list #####

create_counter_list <- function(x, periods) {
  counter_layer <- x
  counter_layer[which(!is.na(values(counter_layer)))] <- 0
  
  list_of_counters = list()
  for (i in 1:periods) {
    list_of_counters <- c(list_of_counters, counter_layer)
  }
  return(list_of_counters)
}

create_ETraster_list <- function(x, periods) {
  ETraster_layer <- x
  
  list_of_ETrasters = list()
  for (i in 1:periods) {
    list_of_ETrasters <- c(list_of_ETrasters, ETraster_layer)
  }
  return(list_of_ETrasters)
}




##### initiate output vectors #####

list_of_counters  <- create_counter_list(lc_raster, periods = simlength)
list_of_ETrasters <- create_ETraster_list(dep_var_raster_pred, periods = simlength)
sum_aet_result <- c()
infested_cell_counts <- c()
mean_aet_result <- c()
median_aet_result <- c()
et_raster <- c()




##### for-loop simulation #####

for (i in 1:simulation_count) {
  simulation_result <- one_simulation(lc_raster, periods = simlength, list_of_counters, old_aet = dep_var_raster_initial, pred_aet = dep_var_raster_pred)
  list_of_counters <- simulation_result$list_of_counters
  list_of_ETrasters <- simulation_result$list_of_ETrasters
  sum_aet_result <- rbind(sum_aet_result, simulation_result$sum_aet)
  infested_cell_counts <- rbind(infested_cell_counts, simulation_result$infested_cells)
  mean_aet_result <- rbind(mean_aet_result, simulation_result$mean_aet)
  median_aet_result <- rbind(median_aet_result, simulation_result$median_aet)
  et_raster[[i]] <- simulation_result$et
  print(paste0('Simulation ', i, ' of ', simulation_count, ' complete!'))
}




##### update counters #####

list_of_summed_counters = list()
for (i in 1:simlength) {
  list_of_summed_counters <- c(list_of_summed_counters, raster :: calc(stack(list_of_counters[1:i]), fun = sum))
}




##### update results #####

infested_value = infest_val
susceptible_values = suscep
spread_rate = spreadrate
bird_rate = birdcell
last_raster <- lc_raster
summary_list_of_rasters <- list(last_raster)
infested_cells <- rep(NA, 100)
for (i in 1:simlength) {
  infested_cell_count <- sum(values(last_raster) == infested_value, na.rm = TRUE)
  adjacent_target_count <- ceiling(infested_cell_count * spread_rate)
  bird_target_count <- ceiling(infested_cell_count * bird_rate)
  
  # spread
  adjacent_cells <- adjacent(last_raster, which(values(last_raster) == infested_value), 
                             directions = 8, pairs = FALSE)
  flippable_cells <- adjacent_cells[values(last_raster)[adjacent_cells] %in% susceptible_values]
  summed_counters_copy <- values(list_of_summed_counters[[i]])
  summed_counters_copy[-flippable_cells] <- 0
  adjacent_targets <- order(summed_counters_copy, decreasing = TRUE)[1:adjacent_target_count]
  last_raster[adjacent_targets[adjacent_targets %in% flippable_cells]] <- infested_value 
  
  # birds
  bird_targets <- sample(which(values(last_raster) %in% c(infested_value, susceptible_values)), bird_target_count)
  last_raster[bird_targets] <- infested_value 
  
  infested_cells[i] <- sum(values(last_raster) == infested_value, na.rm = TRUE)
  
  #writeRaster(last_raster, paste0("C:/Users/nated/OneDrive - hawaii.edu/Documents/Projects/DWS/Land_cover/Data/Processed/Simulation_results_05pct_250m_LAI_CONSTANT_kohala/TIFs_05pct_250m/finalRRaster",simulation_label, 2017 + i, ".tif"), overwrite = TRUE)
  summary_list_of_rasters <- c(summary_list_of_rasters, last_raster)
}





summary(values(ET_predicted_diff))
summary(values(list_of_ETrasters[[50]] - list_of_ETrasters[[1]]))

```
